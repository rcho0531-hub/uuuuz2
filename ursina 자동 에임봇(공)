from ursina import *
from ursina.prefabs.first_person_controller import FirstPersonController
from ursina.shaders import lit_with_shadows_shader
import random

app = Ursina()
mouse.locked = True

# =========================
# 게임 설정
# =========================
GAME_TIME = 60.0
time_left = GAME_TIME
score = 0
game_over = False

# =========================
# DEBUG / ASSIST 설정
# =========================
show_hitbox = False
aim_assist = False

# =========================
# UI
# =========================
timer_text = Text(text='Time: 60', position=(-0.55,0.45), scale=2)
score_text = Text(text='Score: 0', position=(-0.55,0.4), scale=2)
gameover_text = Text(text='GAME OVER', scale=4, color=color.red, enabled=False)

debug_text = Text(
    text='F1: Hitbox  F2: Aim Assist',
    position=(-0.55, 0.35),
    scale=1.5,
    color=color.azure
)

# =========================
# 조명
# =========================
sun = DirectionalLight(shadows=True)
sun.look_at(Vec3(1,-1,1))
Entity.default_shader = lit_with_shadows_shader
AmbientLight(color=color.rgba(120,120,120,0.5))

# =========================
# 바닥
# =========================
GROUND_Y = 0
ground = Entity(model='plane', scale=60, collider='box')

# =========================
# 플레이어
# =========================
player = FirstPersonController(position=(0,2,0), speed=5.5)
player.gravity = 0
player.jump_height = 0

y_velocity = 0
GRAVITY = 30
JUMP_FORCE = 9

MAP_MIN, MAP_MAX = -15, 15
MAX_SPHERE_Y = 20

# =========================
# 파편
# =========================
shard_pool = []

class Shard(Entity):
    def __init__(self):
        super().__init__(model='quad', scale=0.3, enabled=False)
        self.velocity = Vec3()

    def activate(self, pos):
        self.position = pos
        self.velocity = Vec3(
            random.uniform(-6,6),
            random.uniform(5,10),
            random.uniform(-6,6)
        )
        self.color = color.random_color()
        self.enabled = True

    def update(self):
        if not self.enabled:
            return
        self.velocity.y -= 25 * time.dt
        self.position += self.velocity * time.dt
        if self.y <= GROUND_Y:
            self.enabled = False

for _ in range(200):
    shard_pool.append(Shard())

def explode(pos):
    used = 0
    for s in shard_pool:
        if not s.enabled:
            s.activate(pos)
            used += 1
            if used >= 25:
                break

# =========================
# 공 (타겟)
# =========================
obstacles = []

def spawn_obstacle():
    o = Entity(
        model='sphere',
        color=color.orange,
        scale=2,
        position=(
            random.uniform(MAP_MIN,MAP_MAX),
            random.uniform(2,6),
            random.uniform(MAP_MIN,MAP_MAX)
        ),
        collider='sphere'
    )
    o.velocity = Vec3(
        random.uniform(-4,4),
        random.uniform(1,2),
        random.uniform(-4,4)
    )

    # 히트박스 시각화
    o.hitbox = Entity(
        parent=o,
        model='sphere',
        scale=1.1,
        color=color.red,
        wireframe=True,
        enabled=False
    )

    obstacles.append(o)

for _ in range(5):
    spawn_obstacle()

# =========================
# 가장 가까운 공 찾기
# =========================
def get_closest_obstacle():
    if not obstacles:
        return None
    return min(
        obstacles,
        key=lambda o: distance(o.position, player.position)
    )

# =========================
# 업데이트
# =========================
def update():
    global y_velocity, time_left, game_over

    if not game_over:
        time_left -= time.dt
        if time_left <= 0:
            game_over = True
            gameover_text.enabled = True

        timer_text.text = f'Time: {int(time_left)}'
        score_text.text = f'Score: {score}'

    # 중력
    y_velocity -= GRAVITY * time.dt
    player.y += y_velocity * time.dt
    if player.y <= GROUND_Y:
        player.y = GROUND_Y
        y_velocity = 0

    # 공 움직임
    for o in obstacles:
        o.position += o.velocity * time.dt

        if o.y < 1:
            o.y = 1
            o.velocity.y = abs(o.velocity.y)

        for a in ('x','z'):
            if getattr(o,a) < MAP_MIN or getattr(o,a) > MAP_MAX:
                setattr(o.velocity,a,-getattr(o.velocity,a))

        # 히트박스 표시
        o.hitbox.enabled = show_hitbox

    # 에임 어시스트
    if aim_assist:
        target = get_closest_obstacle()
        if target:
            camera.look_at(target.position)

# =========================
# 입력
# =========================
def input(key):
    global y_velocity, score, show_hitbox, aim_assist

    if key == 'space' and player.y <= GROUND_Y + 0.01:
        y_velocity = JUMP_FORCE

    if key == 'tab':
        mouse.locked = not mouse.locked

    if key == 'f1':
        show_hitbox = not show_hitbox

    if key == 'f2':
        aim_assist = not aim_assist

    if key == 'left mouse down' and not game_over:
        target = mouse.hovered_entity
        if target in obstacles:
            explode(target.position)
            obstacles.remove(target)
            destroy(target)
            score += 1
            while len(obstacles) < 5:
                spawn_obstacle()

app.run()
